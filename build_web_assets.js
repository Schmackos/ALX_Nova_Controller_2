#!/usr/bin/env node
/**
 * Web Assets Build Script
 *
 * Processes web_pages.cpp to:
 * 1. Extract raw HTML pages
 * 2. Minify CSS and JavaScript (optional)
 * 3. Generate gzipped byte arrays for efficient serving
 *
 * Usage: node build_web_assets.js [--minify]
 */

const zlib = require('zlib');
const fs = require('fs');
const path = require('path');

const MINIFY = process.argv.includes('--minify');

// Source files
const WEB_PAGES_SRC = 'src/web_pages.cpp';
const LOGIN_PAGE_SRC = 'src/login_page.h';
const OUTPUT_FILE = 'src/web_pages_gz.cpp';

console.log('=== Web Assets Build Script ===');
console.log(`Minification: ${MINIFY ? 'ENABLED' : 'DISABLED'}`);

// Read source files
const webPagesContent = fs.readFileSync(WEB_PAGES_SRC, 'utf8');
const loginPageContent = fs.existsSync(LOGIN_PAGE_SRC)
    ? fs.readFileSync(LOGIN_PAGE_SRC, 'utf8')
    : null;

/**
 * Extract a raw literal asset from C++ source
 */
function extractAsset(content, varName) {
    const regex = new RegExp(`const char ${varName}\\[\\] PROGMEM = R"rawliteral\\(([\\s\\S]*?)\\)rawliteral";`);
    const match = content.match(regex);
    return match ? match[1] : null;
}

/**
 * Simple CSS minifier (removes comments, extra whitespace)
 */
function minifyCSS(css) {
    return css
        .replace(/\/\*[\s\S]*?\*\//g, '')           // Remove comments
        .replace(/\s+/g, ' ')                        // Collapse whitespace
        .replace(/\s*([{}:;,>+~])\s*/g, '$1')       // Remove space around symbols
        .replace(/;}/g, '}')                         // Remove last semicolon
        .replace(/^\s+|\s+$/g, '');                  // Trim
}

/**
 * Minify HTML content (CSS only - JS minification requires a proper parser)
 * Gzip compression handles most redundancy in JS/HTML whitespace anyway
 */
function minifyHTML(html) {
    if (!MINIFY) return html;

    // Only minify CSS in <style> tags (safe - CSS is simpler to minify)
    // Don't touch HTML whitespace as it can break JS strings containing HTML
    html = html.replace(/<style>([\s\S]*?)<\/style>/gi, (match, css) => {
        return '<style>' + minifyCSS(css) + '</style>';
    });

    return html;
}

/**
 * Convert buffer to C hex array format
 */
function toHexArray(buffer) {
    const bytes = [];
    for (let i = 0; i < buffer.length; i++) {
        bytes.push('0x' + buffer[i].toString(16).padStart(2, '0'));
    }

    // Format with 16 bytes per line
    let result = '    ';
    for (let i = 0; i < bytes.length; i++) {
        result += bytes[i];
        if (i < bytes.length - 1) {
            result += ', ';
            if ((i + 1) % 16 === 0) {
                result += '\n    ';
            }
        }
    }
    return result;
}

/**
 * Process an asset: minify (optional) and gzip
 */
function processAsset(name, html) {
    if (!html) {
        console.log(`  [SKIP] ${name}: not found`);
        return null;
    }

    const originalSize = Buffer.byteLength(html, 'utf8');

    // Minify if enabled
    const processed = minifyHTML(html);
    const processedSize = Buffer.byteLength(processed, 'utf8');

    // Gzip with maximum compression
    const gzipped = zlib.gzipSync(Buffer.from(processed), { level: 9 });

    const savings = ((1 - gzipped.length / originalSize) * 100).toFixed(1);

    console.log(`  [OK] ${name}:`);
    console.log(`       Original: ${(originalSize / 1024).toFixed(1)} KB`);
    if (MINIFY) {
        console.log(`       Minified: ${(processedSize / 1024).toFixed(1)} KB`);
    }
    console.log(`       Gzipped:  ${(gzipped.length / 1024).toFixed(1)} KB (${savings}% smaller)`);

    return {
        name,
        data: gzipped,
        hexArray: toHexArray(gzipped),
        length: gzipped.length
    };
}

// Extract assets
console.log('\nExtracting assets...');
const htmlPage = extractAsset(webPagesContent, 'htmlPage');
const apHtmlPage = extractAsset(webPagesContent, 'apHtmlPage');
const loginPage = loginPageContent ? extractAsset(loginPageContent, 'loginPage') : null;

// Process assets
console.log('\nProcessing assets...');
const assets = [
    processAsset('htmlPage', htmlPage),
    processAsset('apHtmlPage', apHtmlPage),
    processAsset('loginPage', loginPage)
].filter(a => a !== null);

// Generate output file
console.log('\nGenerating output...');

let output = `// Auto-generated gzipped web assets
// Generated by build_web_assets.js
// DO NOT EDIT - regenerate with: node build_web_assets.js${MINIFY ? ' --minify' : ''}

#include "web_pages.h"

`;

for (const asset of assets) {
    output += `// Gzipped ${asset.name} (${asset.length} bytes)\n`;
    output += `const uint8_t ${asset.name}_gz[] PROGMEM = {\n`;
    output += asset.hexArray;
    output += '\n};\n';
    output += `const size_t ${asset.name}_gz_len = ${asset.length};\n\n`;
}

fs.writeFileSync(OUTPUT_FILE, output);
console.log(`\nOutput written to: ${OUTPUT_FILE}`);

// Summary
const totalOriginal = assets.reduce((sum, a) => sum + (a ? a.data.length : 0), 0);
console.log(`\nTotal gzipped size: ${(totalOriginal / 1024).toFixed(1)} KB`);
console.log('\nTo use gzipped assets:');
console.log('  1. Include "web_pages_gz.cpp" in your build');
console.log('  2. Use sendGzipped() helper from web_pages.h');
console.log('  3. Set Content-Encoding: gzip header');
